TODO: Reflect on what you learned this week and what is still unclear.

# Experience

> This week was a lot more complex than the last. Although there was another detailed tutorial guide, I felt I didn't quite understand the fundamentals or logic behind many of the steps. A lot of my friends with technical or coding experience breezed through it, but it felt like I had hit a brick wall.
> In my spare time, I've tried to watch tutorials and guides to gain a better understanding, but so far it's been bit of a struggle.

> I'm at the stage where after an explanation or seeing the finished code, I sort of understand. But I'm frustrated as I feel I need to reach the stage where I can code basic things using logic or what was previously taught without needing to see an answer first, or requiring assistance.

> On the bright side, one thing which interested me was that I realised there's a certain amount of incentive to complete the tasks. It's interesting that the change from red to green indicating the successful completion of an exercise, brings a small degree of satisfaction and desire to get a full list of green ticks. I think humans are inherently coded in this way, and when a short-term feedback loop is implemented (video games are an example of this), it's very effective to get people to do small tasks with constant feedback. I'm not sure whether this was intentional, but from what I've been noticing in the little easter eggs and references in the tutorial guide and code, I assume it was on purpose. Applying a psychological aspect to help people learn things in a new course is really appreciated!

# Problems Encountered

> Most of the problems I encountered, was generating the code on my own, without asking for help or looking at the answers. I feel it's really necessary to reach a basic stage where I can look at a simple problem, and then attempt it without a solution.

> It gave me anxiety, as the guide mentioned there was an intentional mistake in one of the videos. If from what I figured out, in loops 4 and 6 of the exercises, STR was missing from the code. After trying my own code and having varying success, I ran the answers in the exercise and it still came back red. The help hints indicated a missing string, so I added STR to: steps.append(str(j)) original was: steps.append(j), and this was the case for both loops 4 and 6 from memory.

> Ran into another problem where it said, "Warning: This Python interpreter is in a conda environment, but the environment has
> not been activated. Libraries may fail to load. To activate this environment please see https://conda.io/activation."
> Rebooting VS code worked to temporarily solve it, but I'm worried if this will have future impact on coding.

# Fixes

> As I mentioned before, adding a STR to loop 4 and 6 made them work. As for the others, most were based on incremental adjustments or logic from the previous exercise. It reminded me a bit of how in law, precedents are used to make a case for some things, and each new precedent allows further solutions or scenarios to be implemented. Loop 7 was totally beyond me, and I had to look at the examples in Week 3 to complete this task. I still don't understand how to generate an original code for this one, so i'll ask a friend next week to help me with this.

# Interesting facts learned

> In one of the videos, it was mentioned that I,J and K are used as loop variables, and the reason for them was that it just was. I think for most people who are familiar with code, they either know the background to it, or have accepted it as a norm without needing the story behind it as they've worked with it for so long.

But for me being new to this sphere, I searched for the reason why I,J,K are used as loop variables and apparently It comes ultimately from mathematics: the summation notation traditionally uses i for the first index, j for the second, and so on. Example (from http://en.wikipedia.org/wiki/Summation):
\sum\_{i=1}^{n} i = \frac{n^2 + n}{2}. (found someone's answer to this on stack overflow: https://stackoverflow.com/questions/4137785/why-are-variables-i-and-j-used-for-counters)

# Supplementary readings

Bouchard, R. Philip, The Oregon Trail Game: Crossing Rivers.

> This was interesting as I had a played a version of The Oregon Trail game at my friends house. I do vividly remember the decision making process in the game, but had never really given any thought to what was behind it. The coding behind the river crossings felt a bit similar to the engineering flowchart we did in exercise 3. I do like how they had to approach the coding from the perspective of someone playing the game, as technically, hiring an indian guide for a 50% risk reduction, did not appeal to players as they dismissed the outcome based on luck. Thus it was increased to 80% to facilitate a better invest - reward scenario.

Noll, A. M. (1967). The digital computer as a creative medium. IEEE Spectrum, 4(10), 89â€“95.

> This was a refreshing read, as most of the articles concerning this concept nowadays are from a negative or cautionary perspective. I found the part where it was mentioned, "the artist would be able to specify and control with certainty the emotional state of each individual participant. Only those aspects deliberately specified by the artist might be left to chance or to the whims of the participant. All this would be possible because the computer could monitor the participant's emotional state and change it according to the artist's specifications".

> This reminded me a lot of the concepts we went through in Nicole's class (CODE1210) last semester, where in one of the classes, we went through Ben's possible futures card game. Also this text reminded me of an essay I wrote towards the end of the class, where the debate question was, "The rise of artificial intelligence means the architecture profession is doomed", and it was interesting to see another perspective concerning the role of computers as a medium within design.
